<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/13/Raft%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%9B%86%E7%BE%A4%E6%88%90%E5%91%98%E5%8F%98%E6%9B%B4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/13/Raft%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%9B%86%E7%BE%A4%E6%88%90%E5%91%98%E5%8F%98%E6%9B%B4/" class="post-title-link" itemprop="url">Raft如何实现集群成员变更</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-08-13 10:40:32 / Modified: 11:08:50" itemprop="dateCreated datePublished" datetime="2021-08-13T10:40:32+08:00">2021-08-13</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>到目前为止，我们都假设集群的配置（加入到一致性算法的服务器集合）是固定不变的。但是在实践中，偶尔是会改变集群的配置的，例如替换那些宕机的机器或者改变复制级别。尽管可以通过暂停整个集群，更新所有配置，然后重启整个集群的方式来实现，但是在更改的时候集群会不可用。另外，如果存在手工操作步骤，那么就会有操作失误的风险。为了避免这样的问题，自动化配置变得尤为重要。</p>
<p>成员变更在一致性协议中算比较复杂的一部分，因为在转换的过程中不能够存在任何时间点使得两个领导人同时被选举成功在同一个任期里。不幸的是，任何服务器直接从旧的配置直接转换到新的配置的方案都是不安全的。一次性原子地转换所有服务器是不可能的，所以在转换期间整个集群存在划分成两个独立的大多数群体的可能性。所以可能会出现两个不相交的majority，从而导致同一个term出现两个leader，进而导致同一个idnex的日志不一样，违反一致性协议。</p>
<p><img src="/img/raft18.png"></p>
<p>raft作者提出了一种更加简单的方法，一次只增加或删除一个成员，这样就保证了任何时刻都至多出现一个leader，保证了成员变更的安全性。</p>
<p><img src="/img/raft17.png"></p>
<p>下面结合代码讲一下<a target="_blank" rel="noopener" href="https://github.com/eraft-io/eraft">eraft</a>是如何实现成员变更的。</p>
<p>首先是发送成员变更请求给leader，在sever处理消息之前，confChange基本上和普通日志复制是类似的。在leader收到客户端的请求时，我们会做简单的处理，包括定义address，id和changetype等，再将请求封装成ChangePeerRequest。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Kv/test_cli.cc</span></span><br><span class="line">raft_cmdpb::ChangePeerRequest confChange;</span><br><span class="line">   std::string confChangeType = std::<span class="built_in">string</span>(argv[<span class="number">3</span>]);</span><br><span class="line">   <span class="keyword">if</span> (confChangeType == <span class="string">&quot;add&quot;</span>)</span><br><span class="line">     confChange.<span class="built_in">set_change_type</span>(eraftpb::AddNode);</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (confChangeType == <span class="string">&quot;remove&quot;</span>)</span><br><span class="line">     confChange.<span class="built_in">set_change_type</span>(eraftpb::RemoveNode);</span><br><span class="line">   metapb::Peer* pr = <span class="keyword">new</span> metapb::<span class="built_in">Peer</span>();</span><br><span class="line">   pr-&gt;<span class="built_in">set_addr</span>(std::<span class="built_in">string</span>(argv[<span class="number">4</span>]));  <span class="comment">// ip</span></span><br><span class="line">   pr-&gt;<span class="built_in">set_id</span>(std::<span class="built_in">atoi</span>(argv[<span class="number">5</span>]));      <span class="comment">// id</span></span><br><span class="line">   pr-&gt;<span class="built_in">set_store_id</span>(std::<span class="built_in">atoi</span>(argv[<span class="number">5</span>]));</span><br><span class="line">   confChange.<span class="built_in">set_allocated_peer</span>(pr);</span><br><span class="line">   raftClient-&gt;<span class="built_in">PeerConfChange</span>(std::<span class="built_in">string</span>(argv[<span class="number">1</span>]), confChange);</span><br></pre></td></tr></table></figure>

<p>将封装好的请求通过raftClient发送给rpc传到服务端。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">//Kv/server/raft_client.cc</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">RaftClient::PeerConfChange</span><span class="params">(std::string addr,</span></span></span><br><span class="line"><span class="params"><span class="function">                                raft_cmdpb::ChangePeerRequest&amp; request)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// TODO</span></span><br><span class="line">  <span class="comment">// 1. 连接</span></span><br><span class="line">  <span class="comment">// 2. 发送到 stub_ 里面</span></span><br><span class="line">  std::shared_ptr&lt;RaftConn&gt; conn = <span class="keyword">this</span>-&gt;<span class="built_in">GetConn</span>(addr, <span class="number">1</span>);</span><br><span class="line">  <span class="function">std::unique_ptr&lt;TinyKv::Stub&gt; <span class="title">stub_</span><span class="params">(TinyKv::NewStub(conn-&gt;GetChan()))</span></span>;</span><br><span class="line">  raft_cmdpb::ChangePeerResponse response;</span><br><span class="line">  grpc::ClientContext context;</span><br><span class="line">  stub_-&gt;<span class="built_in">PeerConfChange</span>(&amp;context, request, &amp;response);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在服务端收到了请求之后，就是我们接下来要做的请求处理，首先我们要将请求封装成一个RaftMessage，并且定义消息类型为RaftConfChange，将封装好的消息通过raft路由发送（push_back）到我们消息处理队列peerSender_，在之前还要进行一次消息的封装，因为消息队列是处理所有的日志，并不都是RaftMessage类型。将我们的RaftMessage封装到Msg当中，并且定义Msg的类型为MsgTypeRaftMessage。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Kv/server/server.cc</span></span><br><span class="line"><span class="function">Status <span class="title">Server::PeerConfChange</span><span class="params">(ServerContext* context,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="keyword">const</span> raft_cmdpb::ChangePeerRequest* request,</span></span></span><br><span class="line"><span class="params"><span class="function">                              raft_cmdpb::ChangePeerResponse* response)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 构造配置变更的消息，发送到 raft group</span></span><br><span class="line">  std::shared_ptr&lt;raft_serverpb::RaftMessage&gt; sendMsg =</span><br><span class="line">      std::make_shared&lt;raft_serverpb::RaftMessage&gt;();</span><br><span class="line">  sendMsg-&gt;<span class="built_in">set_data</span>(request-&gt;<span class="built_in">SerializeAsString</span>());</span><br><span class="line">  sendMsg-&gt;<span class="built_in">set_region_id</span>(<span class="number">1</span>);</span><br><span class="line">  sendMsg-&gt;<span class="built_in">set_raft_msg_type</span>(raft_serverpb::RaftConfChange);</span><br><span class="line">  <span class="keyword">this</span>-&gt;<span class="built_in">Raft</span>(context, sendMsg.<span class="built_in">get</span>(), <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="keyword">return</span> Status::OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Kv/server/router.cc</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">RaftstoreRouter::SendRaftMessage</span><span class="params">(<span class="keyword">const</span> raft_serverpb::RaftMessage* msg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (RaftstoreRouter::raft_msg_ != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="keyword">delete</span> RaftstoreRouter::raft_msg_;</span><br><span class="line">  &#125;</span><br><span class="line">  RaftstoreRouter::raft_msg_ = <span class="keyword">new</span> raft_serverpb::<span class="built_in">RaftMessage</span>(*msg);</span><br><span class="line">  Msg m = <span class="built_in">Msg</span>(MsgType::MsgTypeRaftMessage, msg-&gt;<span class="built_in">region_id</span>(),</span><br><span class="line">              RaftstoreRouter::raft_msg_);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>-&gt;router_-&gt;<span class="built_in">Send</span>(msg-&gt;<span class="built_in">region_id</span>(), m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到了这里，我们已经将我们请求封装成了Msg并放入到消息处理队列，接下来就是处理消息了。消息处理是一个单独的线程，主要看HandleMsg是如何处理消息，和处理完消息发送。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// Kv/server/raft_worker.cc</span><br><span class="line">void RaftWorker::Run(Queue&lt;Msg&gt;&amp; qu) &#123;</span><br><span class="line">  Logger::GetInstance()-&gt;DEBUG_NEW(&quot;raft worker start running!&quot;, __FILE__,</span><br><span class="line">                                   __LINE__, &quot;RaftWorker::Run&quot;);</span><br><span class="line">  std::map&lt;uint64_t, std::shared_ptr&lt;PeerState_&gt; &gt; peerStMap;</span><br><span class="line">  while (true) &#123;</span><br><span class="line">    auto msg = qu.Pop();</span><br><span class="line">    // handle m, call PeerMessageHandler</span><br><span class="line">    std::shared_ptr&lt;PeerState_&gt; peerState =</span><br><span class="line">        RaftWorker::GetPeerState(peerStMap, msg.regionId_);</span><br><span class="line">    PeerMsgHandler pmHandler(peerState-&gt;peer_, RaftWorker::ctx_);</span><br><span class="line">    pmHandler.HandleMsg(msg);</span><br><span class="line">    // get peer state, and handle raft ready</span><br><span class="line">    PeerMsgHandler pmHandlerRaftRd(peerState-&gt;peer_, RaftWorker::ctx_);</span><br><span class="line">    pmHandlerRaftRd.HandleRaftReady();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>首先根据Msg的类型选择如何处理，比如我们这里应该是MsgTypeRaftMessage，拿到RaftMessage，根据类型RaftConfChange，再进一步反序列化拿到ChangePeerRequest，也就是我们最开始的客户端请求类型，再将我们需要的信息封装成ConfChange，通过ProposeConfChange处理，将ConfChange消息序列化为Message，将存储的消息类型设置为EntryConfChange，也就是里面消息的类型，并非Message的类型，Message的类型设置为MsgPropose，因为raft配置变更的消息是和普通日志在一起处理，所以普通日志为EntryNormal，作以区分。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Kv/server/peer_mag_handler.cc</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PeerMsgHandler::HandleMsg</span><span class="params">(Msg m)</span> </span>&#123;</span><br><span class="line">  <span class="built_in"><span class="keyword">switch</span></span> (m.type_) &#123;</span><br><span class="line">    <span class="keyword">case</span> MsgType::MsgTypeRaftMessage: &#123;</span><br><span class="line">      <span class="keyword">if</span> (m.data_ != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">auto</span> raftMsg = <span class="keyword">static_cast</span>&lt;raft_serverpb::RaftMessage*&gt;(m.data_);</span><br><span class="line">          <span class="built_in"><span class="keyword">switch</span></span> (raftMsg-&gt;<span class="built_in">raft_msg_type</span>()) &#123;</span><br><span class="line">			  <span class="keyword">case</span> raft_serverpb::RaftConfChange: &#123;</span><br><span class="line">              <span class="comment">// 构造一个 日志条目 ProposeRaftCommand(), 提交到状态机</span></span><br><span class="line">              std::shared_ptr&lt;raft_cmdpb::ChangePeerRequest&gt; peerChange =</span><br><span class="line">                  std::make_shared&lt;raft_cmdpb::ChangePeerRequest&gt;();</span><br><span class="line">              peerChange-&gt;<span class="built_in">ParseFromString</span>(raftMsg-&gt;<span class="built_in">data</span>());</span><br><span class="line">              &#123;</span><br><span class="line">                eraftpb::ConfChange confChange;</span><br><span class="line">                confChange.<span class="built_in">set_node_id</span>(peerChange-&gt;<span class="built_in">peer</span>().<span class="built_in">id</span>());</span><br><span class="line">                confChange.<span class="built_in">set_context</span>(peerChange-&gt;<span class="built_in">peer</span>().<span class="built_in">addr</span>());</span><br><span class="line">                confChange.<span class="built_in">set_change_type</span>(peerChange-&gt;<span class="built_in">change_type</span>());</span><br><span class="line">                <span class="keyword">this</span>-&gt;peer_-&gt;raftGroup_-&gt;<span class="built_in">ProposeConfChange</span>(confChange);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// RaftCore/src/raw_node.cc</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RawNode::ProposeConfChange</span><span class="params">(eraftpb::ConfChange cc)</span> </span>&#123;</span><br><span class="line">  std::string data = cc.<span class="built_in">SerializeAsString</span>();</span><br><span class="line">  eraftpb::Message msg;</span><br><span class="line">  <span class="comment">/*   package msg */</span></span><br><span class="line">  <span class="keyword">this</span>-&gt;raft-&gt;<span class="built_in">Step</span>(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么接下来就是将消息放入到日志中，也就是AppendEntry。注意这一步是leader执行，还未涉及到follower，在leader处理了日志之后，会将日志发送给follower，follower执行的操作也就是前面所有的操作，只是在Step中选择StepFollower。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RaftCore/src/raft.cc</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">RaftContext::Step</span><span class="params">(eraftpb::Message m)</span> </span>&#123;</span><br><span class="line">  <span class="built_in"><span class="keyword">switch</span></span> (<span class="keyword">this</span>-&gt;state_) &#123;</span><br><span class="line">    <span class="keyword">case</span> NodeState::StateFollower: &#123;</span><br><span class="line">      <span class="keyword">this</span>-&gt;<span class="built_in">StepFollower</span>(m);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> NodeState::StateCandidate: &#123;</span><br><span class="line">      <span class="keyword">this</span>-&gt;<span class="built_in">StepCandidate</span>(m);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> NodeState::StateLeader: &#123;</span><br><span class="line">      <span class="keyword">this</span>-&gt;<span class="built_in">StepLeader</span>(m);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>leader拿到消息后就是AppendEntry。这里做的就是将消息添加到我们的log（具体就是entries_）中。然后更新raftLog_的nextindex(对于每一台服务器，发送到该服务器的下一个日志条目的索引（初始值为领导者最后的日志<br>条目的索引+1）)和matchIndex(对于每一台服务器，已知的已经复制到该服务器的最高日志条目的索引（初始值为0，单调递增）)。然后再将log发送给配置中所有的follower。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// RaftCore/src/raft.cc</span><br><span class="line">void RaftContext::AppendEntry(eraftpb::Message m) &#123;</span><br><span class="line">  uint64_t lastIndex = this-&gt;raftLog_-&gt;LastIndex();</span><br><span class="line">  eraftpb::Entry entry;</span><br><span class="line">  if (m.temp_data() != &quot;&quot;) &#123;</span><br><span class="line">    this-&gt;raftLog_-&gt;entries_.push_back(entry);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  this-&gt;prs_[this-&gt;id_]-&gt;match = this-&gt;raftLog_-&gt;LastIndex();</span><br><span class="line">  this-&gt;prs_[this-&gt;id_]-&gt;next = this-&gt;prs_[this-&gt;id_]-&gt;match + 1;</span><br><span class="line">  this-&gt;BcastAppend();</span><br><span class="line">  if (this-&gt;prs_.size() == 1) &#123;</span><br><span class="line">    this-&gt;raftLog_-&gt;commited_ = this-&gt;prs_[this-&gt;id_]-&gt;match;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发送给follower是根据每个follower的情况发送消息的，因为每个follower已经接收的消息是不同的，由于网络延迟、丢包、分区等原因不可能保证follower和leader时刻同步。所以这就需要再发送日志的时候根据follower的状态发送。prevIndex（紧邻新日志条目之前的那个日志条目的索引），prevLogTerm（紧邻新日志条目之前的那个日志条目的任期）。我们需要先找到follower紧邻新日志条目之前的那个日志条目（也就是follower已经接收了的）索引和任期号，然后将这之后的日志全部打包到Message队列当中发送出去。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RaftCore/src/raft.cc</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">RaftContext::SendAppend</span><span class="params">(<span class="keyword">uint64_t</span> to)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">uint64_t</span> prevIndex = <span class="keyword">this</span>-&gt;prs_[to]-&gt;next - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">uint64_t</span> prevLogTerm = <span class="keyword">this</span>-&gt;raftLog_-&gt;<span class="built_in">Term</span>(prevIndex);</span><br><span class="line">  <span class="keyword">int64_t</span> n = <span class="keyword">this</span>-&gt;raftLog_-&gt;entries_.<span class="built_in">size</span>();</span><br><span class="line">  eraftpb::Message msg;</span><br><span class="line">  <span class="comment">/*  package msg  */</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">uint64_t</span> i = <span class="keyword">this</span>-&gt;raftLog_-&gt;<span class="built_in">ToSliceIndex</span>(prevIndex + <span class="number">1</span>); i &lt; n; i++) &#123;</span><br><span class="line">    eraftpb::Entry* e = msg.<span class="built_in">add_entries</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>-&gt;msgs_.<span class="built_in">push_back</span>(msg);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么HandleMsg就完成，接下来就是HandleRaftReady。主要流程就是取出打包好的日志消息，再将日志消息通过rpc发送给每个follower，发送完之后leader需要对消息进行处理，ApplyConfChange，将成员变更进行实现。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Kv/server/peer_msg_handler.cc</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PeerMsgHandler::HandleRaftReady</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;peer_-&gt;raftGroup_-&gt;<span class="built_in">HasReady</span>()) &#123;</span><br><span class="line">    eraft::DReady rd = <span class="keyword">this</span>-&gt;peer_-&gt;raftGroup_-&gt;<span class="built_in">EReady</span>();</span><br><span class="line">    <span class="comment">// real send raft message to transport (grpc)</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;peer_-&gt;<span class="built_in">Send</span>(<span class="keyword">this</span>-&gt;ctx_-&gt;trans_, rd.messages);</span><br><span class="line">    <span class="keyword">if</span> (rd.committedEntries.<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      std::shared_ptr&lt;rocksdb::WriteBatch&gt; kvWB =</span><br><span class="line">          std::make_shared&lt;rocksdb::WriteBatch&gt;();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">auto</span> entry : rd.committedEntries) &#123;</span><br><span class="line">        kvWB = <span class="keyword">this</span>-&gt;<span class="built_in">Process</span>(&amp;entry, kvWB);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>首先是日志rpc发送，在这里就是对消息进行打包设置，包括发送到哪、从哪来、消息任期、消息类型等。一直到发送，发送最后就是建立一个链接到接收消息的server，也就是follower，那么到这里follower就已经接收到rpc调用，开始执行消息，follower的步骤类似leader，也是消息处理。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// Kv/server/peer.cc</span><br><span class="line">void Peer::Send(std::shared_ptr&lt;Transport&gt; trans,</span><br><span class="line">                std::vector&lt;eraftpb::Message&gt; msgs) &#123;</span><br><span class="line">  for (auto msg : msgs) &#123;</span><br><span class="line">    if (!this-&gt;SendRaftMessage(msg, trans)) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// Kv/server/peer.cc</span><br><span class="line">bool Peer::SendRaftMessage(eraftpb::Message msg,</span><br><span class="line">                           std::shared_ptr&lt;Transport&gt; trans) &#123;</span><br><span class="line">  std::shared_ptr&lt;raft_serverpb::RaftMessage&gt; sendMsg =</span><br><span class="line">      std::make_shared&lt;raft_serverpb::RaftMessage&gt;();</span><br><span class="line">  auto fromPeer = this-&gt;meta_;</span><br><span class="line">  auto toPeer = this-&gt;GetPeerFromCache(msg.to());</span><br><span class="line">/*   package sendmsg   */</span><br><span class="line">  for (auto ent : msg.entries()) &#123;</span><br><span class="line">    eraftpb::Entry* e = sendMsg-&gt;mutable_message()-&gt;add_entries()</span><br><span class="line">  &#125;</span><br><span class="line">  // rpc</span><br><span class="line">  return trans-&gt;Send(sendMsg);</span><br><span class="line">&#125;</span><br><span class="line">// Kv/server/raft_client.cc</span><br><span class="line">bool RaftClient::Send(uint64_t storeID, std::string addr,</span><br><span class="line">                      raft_serverpb::RaftMessage&amp; msg) &#123;</span><br><span class="line">  std::shared_ptr&lt;RaftConn&gt; conn = this-&gt;GetConn(addr, msg.region_id());</span><br><span class="line">  std::unique_ptr&lt;TinyKv::Stub&gt; stub_(TinyKv::NewStub(conn-&gt;GetChan()));</span><br><span class="line">  Done done;</span><br><span class="line">  grpc::ClientContext context;</span><br><span class="line">  auto status = stub_-&gt;Raft(&amp;context, msg, &amp;done);</span><br><span class="line">  &#123;</span><br><span class="line">    std::lock_guard&lt;std::mutex&gt; lck(this-&gt;mu_);</span><br><span class="line">    conns_.erase(addr);</span><br><span class="line">  &#125;</span><br><span class="line">  return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>leader发送完日志之后就是消息处理，如果是添加节点，就加入到配置中，删除就删除节点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Kv/server/peer_msg_handler.cc</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;rocksdb::WriteBatch&gt; <span class="title">PeerMsgHandler::Process</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    eraftpb::Entry* entry, std::shared_ptr&lt;rocksdb::WriteBatch&gt; wb)</span> </span>&#123;</span><br><span class="line">  <span class="built_in"><span class="keyword">switch</span></span> (entry-&gt;<span class="built_in">entry_type</span>()) &#123;</span><br><span class="line">    <span class="keyword">case</span> eraftpb::EntryType::EntryConfChange: &#123;</span><br><span class="line">      eraftpb::ConfChange* cc = <span class="keyword">new</span> eraftpb::<span class="built_in">ConfChange</span>();</span><br><span class="line">      cc-&gt;<span class="built_in">ParseFromString</span>(entry-&gt;<span class="built_in">data</span>());</span><br><span class="line">      <span class="keyword">this</span>-&gt;<span class="built_in">ProcessConfChange</span>(entry, cc, wb);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> wb;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PeerMsgHandler::ProcessConfChange</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    eraftpb::Entry* entry, eraftpb::ConfChange* cc,</span></span></span><br><span class="line"><span class="params"><span class="function">    std::shared_ptr&lt;rocksdb::WriteBatch&gt; wb)</span> </span>&#123;</span><br><span class="line">  <span class="built_in"><span class="keyword">switch</span></span> (cc-&gt;<span class="built_in">change_type</span>()) &#123;</span><br><span class="line">    <span class="keyword">case</span> eraftpb::ConfChangeType::AddNode: &#123;</span><br><span class="line">      metapb::Peer* peer = <span class="keyword">new</span> metapb::<span class="built_in">Peer</span>();</span><br><span class="line">      <span class="keyword">this</span>-&gt;peer_-&gt;<span class="built_in">InsertPeerCache</span>(peer);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> eraftpb::ConfChangeType::RemoveNode: &#123;</span><br><span class="line">      <span class="keyword">this</span>-&gt;peer_-&gt;<span class="built_in">RemovePeerCache</span>(cc-&gt;<span class="built_in">node_id</span>());</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>-&gt;peer_-&gt;raftGroup_-&gt;<span class="built_in">ApplyConfChange</span>(*cc);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">eraftpb::ConfState <span class="title">RawNode::ApplyConfChange</span><span class="params">(eraftpb::ConfChange cc)</span> </span>&#123;</span><br><span class="line">  eraftpb::ConfState confState;</span><br><span class="line">  <span class="built_in"><span class="keyword">switch</span></span> (cc.<span class="built_in">change_type</span>()) &#123;</span><br><span class="line">    <span class="keyword">case</span> eraftpb::AddNode: &#123;</span><br><span class="line">      <span class="keyword">this</span>-&gt;raft-&gt;<span class="built_in">AddNode</span>(cc.<span class="built_in">node_id</span>());</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> eraftpb::RemoveNode: &#123;</span><br><span class="line">      <span class="keyword">this</span>-&gt;raft-&gt;<span class="built_in">RemoveNode</span>(cc.<span class="built_in">node_id</span>());</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> confState;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h5><p>-[1] <a target="_blank" rel="noopener" href="http://files.catwell.info/misc/mirror/2014-ongaro-raft-phd.pdf">CONSENSUS: BRIDGING THEORY AND PRACTICE</a></p>
<p>-[2] <a target="_blank" rel="noopener" href="https://www.usenix.org/system/files/conference/atc14/atc14-paper-ongaro.pdf">In Search of an Understandable Consensus Algorithm</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">1</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
